{
  "blocks": [
    {
      "breadcrumbs": [
        "Why Flogram"
      ],
      "href": "/tutorials/why-flogram",
      "content": "You may be wondering why you should learn another programming language. What does Flogram have to offer that other languages don’t?\n\nVersions for Beginner\nSimplicity is Key\nIn Flogram, we believe that less is more. Unlike older languages that keep adding new features, Flogram sticks to a simple, straightforward way of doing things. Think of it like a toolset where every tool has a specific, clear purpose. This makes it easier for you to learn and use the language.\n\nGo With the Flow or Go Fast\nFlogram offers you two ways to code: “Flow mode” and “Fast mode”. In Flow mode, you can write simple, clean code that runs quickly. If you need more speed, switch to Fast mode to tap into advanced features. It’s like having a car with an “Economy” and “Sport” driving mode; you can choose what suits you best and switch back and forth as needed.\n\nA Fresh Way to Program\nFlogram introduces a new way of programming called ‘flow programming’. We’ve kept the syntax simple, similar to Python, to make it easier for you to read and write code. Imagine learning a new language that feels like a blend of your favorites!\n\nAll-in-One Language\nDream of coding everything in one language? Flogram is working on that! We aim to be a one-stop-shop for all your coding needs, from creating websites to managing databases. This means you won’t have to juggle multiple languages to build a project.\n\nBuilt for Speed\nFlogram is designed to be fast, really fast. While we’re still in the alpha stage, our goal is to eventually outpace even the quickest languages like C. So you can focus on coding without worrying about slow performance.\n\nDebugging Made Easy\nWe’ve eliminated many common pitfalls that make debugging a nightmare in other languages. Flogram is built to minimize bugs and make it easier for you to find and fix errors. It’s like having a built-in safety net for your code without requiring the same mental overhead other languages do to maintain it.\n\nKeep it Simple, Smart\nIn Flogram, you don’t have to worry about complex rules for how data is accessed or changed as required for languages like C or Rust or Zig. The language automatically handles these details for you, making it easier to write safe and reliable code. It’s like having a helpful guide that ensures you’re always on the right path.\n\nConsistency Throughout\nIn Flogram, everything works in a uniform manner. Whether you’re working with simple numbers or complex objects, the rules are the same. This makes it easier for you to understand what your code is doing.\n\nBuilt for the Future\nFlogram is designed to work well with AI, making it a future-proof choice. We envision a world where humans and AI collaborate to write code, with Flogram serving as the common language.\n\nVersion For Professional Programmers:\nOne way to do one thing\nA lot of commonly used languages are old. And over time they’ve introduced new and arguably better ways of doing the same things. But they still allow the old ways to work for the sake of backwards compatibility. The problem is that developers might use old features as well as new and now when working on teams in particular, programmers need to know the entire language which increases complexity and cognitive overhead.\n\nWhile more powerful, Flogram wants to be like C in the sense that it is extremely well designed and will have minimal new features added over time. Flogram’s design is based on the best practices that have emerged over time.\n\nThe only deviations to this are in some places we have the default simple way to do something and the subtly different but higher performance way of doing things that leaves you with the risk of adding hard to debug bugs.\n\nFlow programming paradigm\nFlogram doesn’t fit neatly into an existing paradigm. Rather we are saying Flogram belongs to a new ‘flow programming’ paradigm. We try to stick to a ‘Python like’ syntax for ease of learning and familiarity and because it improves readability of code but we have some new ideas included. Many ideas in Flogram come from other languages like Rust. But we try to simplify things for both ease of learning as well as reducing cognitive overhead while working with the language.\n\nEverything in one language\nThough still a work in progress, Flogram’s goal is to be a full stack language. This means it’s one simple language that can replace: html, css, javascript, a ui framework, a backend language, a language for sending data like JSON, a database language, and a configuration file language.\n\nRest API calls can be replaced with function calls. Programmers spend the majority of their time dealing with code at the boundaries of languages. Anytime two languages need to work together, it greatly hurts productivity. So we’ve decided to make those boundaries as seamless as possible including having both sides capable of working using a similar language.\n\nWe currently have a frontend and backend language working with the ability to work with javascript libraries. More pieces are coming soon.\n\nFlogram is FAST\nA lot of languages claim to be fast. Flogram is designed so that it can run faster than C. We achieve this by building features in a way that is both fast and simple. For example, we have a better faster memory manager that seamlessly and invisibly integrates with the high level language. Additionally, Flogram’s features allow writing code at a very high level without thinking about the low level details while allowing programmers to think about and enforce them if desired with a simplified Rust like ownership system.\n\nNote that we are only releasing an alpha at the moment, a number of compile time optimizations have yet to be added even though they are planned. So, while still a fairly fast language, it can’t achieve better than C like speed just yet. Our goal is to build out language features knowing the optimizations we can add later, get it reasonably fast and optimize to achieve peak performance later.\n\nAnything in Flogram marked with !! is similar to Rust’s unsafe feature and will be similar to standard Flogram features but can occasionally enable optimizations that naturally blend with the rest of the language.\n\nFlogram is easy to debug\nFlogram has eliminated features from the language that make it harder to debug code and found better workarounds. This includes eliminating function pointers, inheritance, and recursive loops in function calls. In Flogram, variables are “read-only” by default. This means once a variable is set, it can’t be changed unless you explicitly allow it by using the mut keyword. This design feature narrows down the potential sources of bugs related to variable modification, making your debugging process more efficient and your code more robust.\n\nSome examples of Flogram minimizing bugs are:\n\nBy having math work in a way that doesn’t require thinking about order of operations, sneaky math bugs are eliminated.\nFlogram doesn’t allow variable shadowing.\nFlogram is simple\nFlogram has an ownership system that is as powerful as Rust while being much simpler and practically invisible. For example, Flogram can check Rust-like lifetimes of variables and guard against move errors without users needing to annotate lifetimes.\n\nWe’ve been very careful about which features we’ve added to the language vs leaving out. When possible we’ve combined features. An example of this is Flogram’s objects which function as both structs and classes in other languages since really they are the same thing.\n\nUnlike Rust and most languages, Flogram assignment uses the simpler to reason about copy by default for both primitives and objects. Unless the user opts into ‘move by default’ mode to allow them to see optimizations.\n\nYou will practically not need to learn any symbols to use Flogram. Other than a few natural and frequently used exceptions, we try to stick to short keywords over symbols.\n\nFlogram is uniform\nA lot of things in Flogram have been polished to work the same way.\n\nFor example, unlike a lot of languages that pass objects around using hidden pointers but primitive variables by value, both primitives and objects in Flogram are ‘passed by value’. This means you don’t have to think about different rules whether working with variables or objects or enums.\n\nFlogram is made for AI\nBetween designing the language to allow stricter compile time checks and being made to read like plain english, Flogram is made to be written by AI and read by humans who can verify the code is doing what they expect. We believe the future of coding is humans manipulating English descriptions of programs which AI turns into code, then humans also providing code reviews since AI makes mistakes that must be corrected."
    },
    {
      "breadcrumbs": [
        "Comments"
      ],
      "href": "/tutorials/comments",
      "content": "Welcome to your first lesson on Flogram, a programming language designed for simplicity and power. Before we dive into variables, functions, and all those exciting topics, let’s start with something foundational yet often overlooked: comments.\n\nComments allow you to annotate your code with descriptive text, making it easier for both you and others to understand what the code is doing and why. In Flogram, adding a comment is easy—you just use the # symbol followed by your comment text.\n\nSingle-Line Comments\nIn Flogram, you can add a single-line comment by starting the line with a # symbol:\n\n# This is a single-line comment\nThe comment will extend to the end of the line, and Flogram will ignore it when running the code.\n\nWhy Use Comments?\nGood code is self-explanatory most of the time, thanks to well-named variables and straightforward logic. However, there are times when explaining the why behind a piece of code becomes essential. That’s where comments come in handy. Here are some good use-cases:\n\nExplaining complex or unintuitive logic\nProviding context or rationale for why a particular solution was chosen\nMarking TODOs or temporary hacks\nProviding meta-information, such as authorship or modify date\nBest Practices\nWhile commenting is good, over-commenting or stating the obvious can clutter your code and make it harder to read. Stick to these best practices:\n\nCode Tells You How, Comments Tell You Why: Your code should be self-explanatory. Comments should generally explain why you’re doing something, not what you’re doing.\nBe Concise: Keep your comments short and to the point.\nKeep Them Updated: Outdated comments can be more confusing than no comments at all. Which is a big reason you should use them sparingly.\nExample: Good vs. Bad Comments\nHere are examples to illustrate:\n\n# Good: Explains the why, not the how\n# Using bitwise shift to perform fast division by 2\nresult = n >> 1\n\n# Bad: Stating the obvious, which code already explains\nresult = n + 1  # Increments n by 1\nIn this introductory lesson, we haven’t covered what the code is doing, but we wanted to highlight the importance of commenting and how to do it effectively. As you continue through the course, you’ll see how comments can be integrated effectively into more complex examples. Note because this is a tutorial, I will at times go against my own advice and add comments that explain what the code is doing because that is the purpose of a tutorial and different from normal code."
    },
    {
      "breadcrumbs": [
        "Functions"
      ],
      "href": "/tutorials/functions",
      "content": "Introduction to Functions in Flogram\nIt’s finally time to write some actual code using Flogram! In this lesson, we’ll be introducing the concept of functions in Flogram and how they are used to organize and execute code.\n\nNote that this tutorial introduces concepts in the order that you should prefer them for the sake of maximizing productivity and performance.\n\nWhat is a function?\nIn programming, a function is a block of code that can be executed by calling it by its name. Functions are useful for organizing and reusing code, as well as for breaking up large programs into smaller, more manageable pieces.\n\nDeclaring a function in Flogram\nIn Flogram, functions are declared using the fn keyword, followed by the function’s name and a set of parentheses. For example, the code below declares a function named main:\n\nfn main():\n\n\uD83D\uDCDD Note: When declaring functions, function names are not allowed to start with uppercase letters. Lowercase letters and symbols are allowed.\n\nThe main function\nIn Flogram, the main function is the starting point of a program. This is where execution of the program begins after which point the program executes one line at a time. The main function is declared in the same way as any other function, but it must be set as the main file by right clicking on it and selecting “Set as main file” in the Flogram IDE (Coming soon).\n\nThe body of a function\nThe code that makes up the function’s behavior is placed within the function’s body. The body of a function is denoted by indenting the code following the function’s declaration. The body of the main function in Flogram might look like this:\n\nfn main():\n\t# The following line calls a different function defined elsewhere\n\t# in the program that prints text to the screen\n\tdraw(\"I am excited to learn Flogram\")\nIn the above example the main function calls the draw function which draws the string “I am excited to learn Flogram” to the screen. You may run this code by clicking on the green ‘Run’ on the right.\n\nWhat are Blocks?\nIn Flogram, a “block” is a chunk of code that belongs together. You start a block with a colon : and then write the following code that belongs to that function under this and indented. Any code that has the same level of indentation belongs to the same block of code. A block ends when the indentation level is decreased. Blocks are used in functions, control structures, and other parts of the Flogram language to define scope and encapsulate code.\n\nFor example:\n\nfn main():  # The colon starts a new block\n\tdraw(\"Hello!\")  # This line is indented, so it belongs to the main function\nConclusion\nIn this lesson, we’ve covered the basics of functions in Flogram and how they are used to organize and execute code. We’ve also introduced the main function and how it is used to begin execution of a Flogram program."
    },
    {
      "breadcrumbs": [
        "Constants"
      ],
      "href": "/tutorials/constants",
      "content": "In this lesson, we’ll take a closer look at how to create and use constants in Flogram.. We’ll cover how to declare constants with explicit and implicit types.\n\nConstants are used to store data. The data being stored can have different types associated with the data, such as integers only, or the ability to store text. We’ll dive deeper into this in the next lesson.\n\nDeclaring Constants\nIn Flogram, constants are declared by specifying the constant name, a colon, the type, an equals sign, and the value assigned to the constant in that order.\n\nFor example:\n\nPI: FP64 = 3.14\nThis creates a constant named PI, of type FP64 (which is a 64 bit floating point number) and sets its value to 3.14 We will dive into the predefined types that Flogram variables can take in the next lesson.\n\nAlternatively, constants in Flogram may also be created with implicit typing by simply omitting the type. In this scenario the type is automatically inferred from the context.\n\nFor example:\n\nlanguage_name := \"Flogram\"\nThis creates a constant named language_name with an inferred type of String and sets its value to “Flogram”.\n\nOnce a constant is created, its value cannot be later changed.\n\n\uD83D\uDCDD Note: We generally recommend using implicit typing. The Flogram IDE can show you what the implicit types resolve to later if desired and you don’t have to worry about the mental overhead of thinking about what type to use.\n\nDrawing constants\nfn main ():\n    mut language_name := \"Flogram\"\n    language_name = \"C\"\n    draw(\"{language_name} is a fun language\")\nScope of Constants and Blocks of Code\nConstants declared within a block of code are only valid from the line they are declared at until the end of the current block of code.\n\nWe will explain this further once we cover creating your own functions.\n\nConclusion\nIn this lesson, we’ve covered the basics of constants in Flogram, including how to declare constants with explicit and implicit typing.\n\nIn the next lesson, we’ll take a deeper dive into how to use constants in your Flogram programs and explore more advanced concepts such as scope and lifetime.\n\nAs you learn Flogram, keep in mind that the language is designed with two primary goals in mind: high productivity and high-performance. Here are a few tips to keep in mind as you work with constants:\n\nInitialize constants as close to the point of use as possible, rather than at the top of a function or block.\nAlways use the smallest constant type that can represent the data to save memory, which can also impact performance."
    },
    {
      "breadcrumbs": [
        "Primitive Types in Flogram"
      ],
      "href": "/tutorials/primitives",
      "content": "In Flogram, constants can be of various core data types, each serving different purposes and having unique characteristics.\n\nIntegers\nIntegers are whole numbers without fractions that can be positive, negative, or zero. They are represented using I followed by the bit length. For example, I32 represents a 32-bit integer.\n\nUnsigned Integers\nUnlike integers, unsigned integers can only be positive or zero. They are denoted with U followed by the bit length. For instance, U8 is an 8-bit unsigned integer.\n\nFloating-Point Numbers\nFloating-point numbers can represent real numbers, including fractions. They can be 32 or 64 bits and are represented using FP32 or FP64.\n\nCharacters\nCharacters represent single Unicode scalar values, usually occupying 8 bits.\n\nBool\nA boolean data type, represented as Bool, can have one of two values: TRUE or FALSE.\n\nTable: Primitive Types in Flogram\nBasic Type\tExample\tDescription\nInteger\tI8, I16, I32, I64\tSigned integer of length 8, 16, 32, or 64 bits\nUnsigned Integer\tU8, U16, U32, U64\tUnsigned integer of length 8, 16, 32, or 64 bits\nFloating Point\tFP32, FP64\tNumbers that allow decimals of length 32 or 64 bits\nCharacter\tChar\tUnicode character, 8 bits\nBoolean\tBool\tBoolean value, TRUE or FALSE\nType Inference\nType inference is Flogram’s way of picking the type for you if you don’t explicitly specify it.\n\nIf type inference is used for plain numbers in code represented by text including integers, unsigned integers, and floating-point numbers default to 32-bit length. If the assigned number doesn’t fit into 32 bits, it’s upgraded to 64 bits.\n\nThis is one place where you may want to explicitly type your declarations.\n\nExample Code\nHere’s an example of Flogram code declaring various variables of different types and lengths:\n\nanswer: I32 = 42\ny: U8 = 255\npi: FP64 = 3.14\na: Char = 'A'\nflag: Bool = TRUE\nThis code declares five variables with different primitive types and assigns them initial values. The specific length of the integers and floating-point numbers is explicitly stated."
    },
    {
      "breadcrumbs": [
        "Primitive Types in Flogram"
      ],
      "href": "/tutorials/primitives",
      "content": "In Flogram, constants can be of various core data types, each serving different purposes and having unique characteristics.\n\nIntegers\nIntegers are whole numbers without fractions that can be positive, negative, or zero. They are represented using I followed by the bit length. For example, I32 represents a 32-bit integer.\n\nUnsigned Integers\nUnlike integers, unsigned integers can only be positive or zero. They are denoted with U followed by the bit length. For instance, U8 is an 8-bit unsigned integer.\n\nFloating-Point Numbers\nFloating-point numbers can represent real numbers, including fractions. They can be 32 or 64 bits and are represented using FP32 or FP64.\n\nCharacters\nCharacters represent single Unicode scalar values, usually occupying 8 bits.\n\nBool\nA boolean data type, represented as Bool, can have one of two values: TRUE or FALSE.\n\nTable: Primitive Types in Flogram\nBasic Type\tExample\tDescription\nInteger\tI8, I16, I32, I64\tSigned integer of length 8, 16, 32, or 64 bits\nUnsigned Integer\tU8, U16, U32, U64\tUnsigned integer of length 8, 16, 32, or 64 bits\nFloating Point\tFP32, FP64\tNumbers that allow decimals of length 32 or 64 bits\nCharacter\tChar\tUnicode character, 8 bits\nBoolean\tBool\tBoolean value, TRUE or FALSE\nType Inference\nType inference is Flogram’s way of picking the type for you if you don’t explicitly specify it.\n\nIf type inference is used for plain numbers in code represented by text including integers, unsigned integers, and floating-point numbers default to 32-bit length. If the assigned number doesn’t fit into 32 bits, it’s upgraded to 64 bits.\n\nThis is one place where you may want to explicitly type your declarations.\n\nExample Code\nHere’s an example of Flogram code declaring various variables of different types and lengths:\n\nanswer: I32 = 42\ny: U8 = 255\npi: FP64 = 3.14\na: Char = 'A'\nflag: Bool = TRUE\nThis code declares five variables with different primitive types and assigns them initial values. The specific length of the integers and floating-point numbers is explicitly stated."
    },
    {
      "breadcrumbs": [
        "Variables"
      ],
      "href": "/tutorials/variables",
      "content": "Introduction\nWelcome to this lesson on variables in Flogram! Variables are essential in programming as they allow us to store, manipulate, and retrieve data. In this lesson, we’ll explore how variables work in Flogram and how they differ from constants.\n\nConstants vs. Variables\nConstants: Constants are values that cannot be changed once declared. They’re useful for defining values that will remain the same throughout a program.\nVariables: Unlike constants, variables in Flogram can change their value during the execution of a program. This improves performance in some cases and allows data to be changed within loops which will be explained later.\nDeclaring Constants\nIn Flogram, as previously explained, you declare a constant using the following syntax:\n\npi: FP64 = 3.14\nletter: Char = 'A'\nThe type and value of the constant are defined at the time of declaration, and they cannot be changed later.\n\nNormally in Flogram you should use a new constant with a different name instead of using a variable:\n\ntemperatureBefore :=  readThermometer()\ntemperatureAfter := readThermometer()\nDeclaring Variables\nVariables in Flogram are declared similarly to constants, but with the keyword mut to indicate that the value can change or in other words is ‘mutable’. Here’s the syntax:\n\nmut video_chat_enabled := FALSE\nThis creates a variable with the name ‘video_chat_enabled’ with an inferred type of bool (boolean) which is equal to FALSE\n\nThe value of video_chat_enabled may now be changed using an equals sign = without a colon :\n\nvideo_chat_enabled = TRUE\nExample: Constants vs. Variables\nConsider the following code snippet, where we use both constants and variables:\n\nfn main():\npi:= 3.14\ndraw(\"The value of Pi is: \")\ndraw(pi)\n\nmut temperature_C:= 25.0\ndraw(\"Current temperature: \")\ndraw(temperature)\n\ntemperature_C = 30.0\ndraw(\"Updated temperature: \")\ndraw(temperature_C)\nHere, the value of pi remains the same throughout the code, while the value of temperature changes.\n\n\uD83D\uDCDD Note:This code can be combined together into one line, we will explain more in the tutorial on Strings:\n\ndraw(\"The value of Pi is: \")\ndraw(pi)\nVersion that combines these together:\n\ndraw(\"The value of Pi is: {pi}\")\nProductivity Tips!\nUse constants instead of variables when the value is not going to change. Constants are needed much less often than most people use them.\nDo not worry about efficiency, Flogram will automatically reuse memory for you and using fresh constants to track state change instead of changing variables often leads to more maintainable programs and reduces bugs.\nAvoid using the same variable for different things in the same scope.\nSummary\nIn this lesson, we’ve introduced the concept of variables in Flogram and explored how they differ from constants. Variables are a powerful tool in programming, allowing for dynamic and high-performance behavior in your code. Remember, while constants remain the same, variables can change their value, providing versatility to your programming projects. In the next lessons, we’ll explore more ways to use and manipulate variables and other data types in Flogram."
    },
    {
      "breadcrumbs": [
        "Casting"
      ],
      "href": "/tutorials/casting",
      "content": "In programming, casting refers to the conversion of a variable from one data type to another. In Flogram, you can cast between primitive types and even use object constructors for casting between different object types. Casting Between Primitive Types In Flogram, you can cast a variable from one primitive type to another. Here’s an example of casting an integer (I32) to a floating-point number (FP32): Casting Between Objects We’ll introduce objects soon but for those of you who know what they are from other languages, note that since object constructors work the same way as casting, you can also use them to cast from one type of object to another. This is just one more way that primitives and objects Flogram function the same and you don’t have to learn different rules for the two. Productivity tip! You should usually convert from one primitive type to another in a way that minimizes the amount of information that is lost. For example, Integers to Floating Point, less bits to more bits. This is likely to prevent bugs. Summary You can cast between primitive types using the syntax NewType(oldVariable). Object constructors can be used for casting between different object types, providing flexibility in handling complex data structures."
    },
    {
      "breadcrumbs": [
        "Math"
      ],
      "href": "/tutorials/maths",
      "content": "Mathematical operations in Flogram are performed using a syntax similar to traditional infix operators, but with a few key differences. Parentheses are required for operations involving multiple terms, but the outermost parentheses can be omitted. 📝 Note: Flogram does not use order of operations, parenthese must be used instead Arithmetic Operations Addition: Use a + b to add a and b. If there are multiple terms, parentheses are required, e.g., (a + b) + c. Subtraction: Use a - b to subtract b from a. If there are multiple terms, parentheses are required, e.g., (a - b) - c. Multiplication: Use a * b to multiply a and b. If there are multiple terms, parentheses are required, e.g., (a * b) * c. Division: Use a / b to divide a by b. If there are multiple terms, parentheses are required, e.g., (a / b) / c. Type Conversion for Math Operations Before performing mathematical operations, values must be converted to the same type. This ensures that the calculation is performed correctly, regardless of the original types of the operands. For example, if you have an integer x and a floating-point number y, you would first cast x to FP32 before adding them: x := 5 # type inference makes this a I32 y := 2.5 # type inference knows to use FP32 sum := FP32(x) + y # We must convert I32 to FP32 as we can only add numbers of the same type Summary Mathematical operations in Flogram are performed using infix operators like a + b, with parentheses required for operations involving multiple terms. The outermost parentheses can be omitted, e.g., a + (b / c) instead of (a + (b / c)). Values must be converted to the same type before performing math operations. By understanding casting and mathematical operations in Flogram, you can write efficient and precise code that takes full advantage of the language’s unique features."
    },
    {
      "breadcrumbs": [
        "Conditionals in Flogram"
      ],
      "href": "/tutorials/conditional",
      "content": "Conditionals in Flogram function like math does but instead return either a TRUE or FALSE boolean value. Conditionals are used to compare two numbers to each other. These include: <, <=, ==, >=, <"
    },
    {
      "breadcrumbs": [
        "Boolean Operators"
      ],
      "href": "/tutorials/boolean_operator",
      "content": "Boolean operators are similar to math and conditionals in Flogram, but boolean operators take in two boolean values and return another boolean value. Specifically: and, or, xor"
    },
    {
      "breadcrumbs": [
        "Arrays and Vectors in Flogram"
      ],
      "href": "/tutorials/arrays",
      "content": "Arrays are a fundamental concept in programming that allows us to store multiple values of the same type together. Declaring an Array You can declare an array in Flogram using square brackets []. Here are a few examples: When declaring an array, you can specify the type explicitly using the syntax [type], or let Flogram infer the type based on the values you provide. If you don’t provide any initial values, you can create an empty array using []. Empty arrays cannot have their type inferred and must use explicit assignment and set the type of the array. You can also specify the capacity of an array using the capacity parameter. The capacity represents the maximum number of elements the array can hold without resizing. If not specified, the capacity defaults to the length of the array. Accessing Elements You can access elements in an array using their index (position) within square brackets. Array indices start from 0, so the first element is at index 0, the second at index 1, and so on: Modifying Elements To modify an element in an array, you can assign a new value to a specific index: Remember to declare the array as mutable using the mut keyword if you intend to modify its elements.Array Length You can find the length of an array using the size function, which returns a U64 (unsigned 64-bit integer): Summary Arrays provide a convenient way to store and manipulate collections of data in Flogram. With the updated syntax, declaring and working with arrays is more concise and intuitive. Remember to specify the type when needed, and use the capacity parameter to optimize memory usage for larger arrays."
    },
    {
      "breadcrumbs": [
        "Strings in Flogram"
      ],
      "href": "/tutorials/strings",
      "content": "Characters can be used to represent letters or numbers. Strings are a sequence of characters and are one of the most common data types used in programming. In Flogram, strings are represented as arrays of characters, providing compatibility with JavaScript. Declaring a String Strings in Flogram can be declared as such: Accessing Characters Strings are effectively just arrays of characters, you can access individual characters using their index, just like you would with an array: Concatenating Strings. You can concatenate strings using {} within a string which will expand variables into strings: String Length You can find the length of a string using the size function, the same way you would with an array: Strings are versatile and essential in any programming language, providing a way to handle text data. In Flogram, strings are treated as arrays of characters, allowing for convenient manipulation and access to individual characters."
    },
    {
      "breadcrumbs": [
        "Function Parameters in Flogram"
      ],
      "href": "/tutorials/function_parameters",
      "content": "Welcome to another exciting lesson in Flogram! Today, we’ll explore function parameters, which enable functions to take input constants and variables and operate on them. Understanding function parameters is key to creating flexible and reusable code. What are Function Parameters? In Flogram, a function parameter is a variable used inside a function to represent the value passed into the function when it’s called. Parameters allow you to define functions that can work with different inputs, making them more flexible. Declaring Function Parameters Function parameters are declared by specifying the variable name (lowercase) followed by the type of the variable (uppercase). Here’s the basic syntax: Passing Parameters by Value In Flogram, function parameters are passed by value, also known as pass by copy. This means that a copy of the value is passed into the function, and changes to the parameter within the function do not affect the original value outside the function. Note the majority of the time we optimize this for you so no copy is actually needed. Calling Functions with Parameters To call a function and pass values to its parameters, you provide the values in the same order as the parameters were declared. Here’s an example of calling the sum function: Function parameters are a powerful feature in Flogram that allows functions to operate on different inputs. By understanding how to declare and use function parameters, you can write code that is more reusable and adaptable to various needs. Remember that in Flogram, parameters are passed by value, meaning that they are copied into the function and do not affect the original values. Happy coding, and see you in the next lesson!"
    },
    {
      "breadcrumbs": [
        "Functions with Mutable Parameters in Flogram"
      ],
      "href": "/tutorials/mutable_parameters",
      "content": "In our last lesson, we looked at function parameters in Flogram and how they allow functions to work with various inputs. In this lesson, we’re diving deeper to explore mutable parameters, which allow functions to modify the values passed into them. This powerful feature allows you to change a variable within a function which can improve performance by avoiding unnecessary copying. Mutable Parameters In Flogram, you can declare a function parameter as mutable using the mut keyword. This means that the function has the ability to change the value of the parameter, and this change will be reflected outside the function. Syntax for Mutable Parameters To declare a mutable parameter, use the mut keyword in the function signature: When calling a function with a mutable parameter, you must also use the mut keyword to explicitly acknowledge that the value might be changed: Productivity tip! If you have a bug in your code and something changed for an object in an unexpected way, you don’t have to worry about looking through function calls that don’t pass the object in using ‘mut’. In general this is the beauty of constants by default, it significantly reduces the amount of debugging you need to do. Working with Mutable and Immutable Parameters You can use mutable, and immutable parameters together in your code. Here’s an example that illustrates these concepts: Mutable parameters in Flogram offer a new level of control and flexibility in how functions interact with their input. By understanding the distinction between mutable, immutable, and copy parameters, you can create more nuanced and expressive functions. Remember to use the mut keyword with care, we will usually optimize your code for you if you pass in a constant and return one. Happy coding, and see you in the next lesson!"
    },
    {
      "breadcrumbs": [
        "Boolean Operators"
      ],
      "href": "/tutorials/boolean_operators",
      "content": "Booleans are a fundamental type in programming that can hold one of two values: TRUE or FALSE. They are incredibly useful for decision making in your code, as you will soon see when we introduce conditional statements like if and loops like while. But first, let’s master the basics of Booleans and Boolean operators. What are Booleans? Booleans represent truth values and are named after George Boole, who first defined an algebraic system of logic in the mid-19th century. In Flogram, as in many programming languages, the Boolean values are denoted as TRUE and FALSE. Creating Boolean Variables In Flogram, you can create a Boolean constant by using the := operator. If you want a Boolean that can change during the execution of your program, you prepend mut to declare a mutable Boolean variable. Here’s how you can create Booleans: isTodaySunny := TRUE  # A Boolean constant mut isShopOpen := FALSE  # A mutable Boolean variable Boolean Operators Booleans become particularly powerful when used with Boolean operators. These operators allow you to combine or invert Boolean values. Here are the basic Boolean operators in Flogram: Logical AND (and): This operator returns TRUE if both operands are true. Logical OR (or): This operator returns TRUE if at least one of the operands is true. Here’s how you might use these operators: isHoliday := TRUE isWeekend := FALSE canRelax := isHoliday or isWeekend  # Evaluates to TRUE Comparison Operators To compare values and derive a Boolean result, Flogram uses standard comparison operators. Here are the key comparison operators: Equal to (==): Checks if two values are equal. Not equal to (!=): Checks if two values are not equal. Greater than (>), Less than (<), Greater than or equal to (>=), Less than or equal to (<=). Examples of using comparison operators: savingsBalance := 1200 checkingBalance := 2000 # isSavingsLess is TRUE because 1200 is less than 2000 isSavingsLess := savingsBalance < checkingBalance Using Boolean and Comparison Operators Together Combining comparison and Boolean operators can lead to more complex and useful expressions: participantAge := 16 minAge := 12 maxAge := 20 # isEligible is TRUE because 16 is between 12 and 20 isEligible := (participantAge > minAge) and (participantAge < maxAge) Summary Booleans and Boolean operators are essential for controlling the flow of logic in your programs. They help you make decisions within your code, determining whether certain blocks of code execute. As you progress, you’ll see how these simple tools enable complex and powerful functionalities in your Flogram applications, aligning with Flogram’s goals of simplicity and performance. By understanding Booleans, you’re taking a big step towards writing more dynamic and responsive programs."
    },
    {
      "breadcrumbs": [
        "If Statements"
      ],
      "href": "/tutorials/if_statements",
      "content": "In this tutorial, we’ll explore how to use if statements in Flogram to make decisions in your code. if statements allow you to execute different parts of your code based on certain conditions. What is an If Statement? An if statement checks a condition: if the condition is true, it executes a block of code. Flogram simplifies decision-making in code by using if statements, although it does not support else directly because using switch cases (which we will cover in a future lesson) is generally recommended for more complex conditions. Basic Syntax of If Statements In Flogram, you write an if statement using the if keyword followed by a condition. Here’s a basic example: fn checkEqual(a: I32, b: I32):   if a == b:     draw(\"a and b are equal\") This function, checkEqual, will display a message if a and b are equal. Checking Temperature Let’s use an if statement to check if the temperature is suitable for a picnic: fn decidePicnic(temperature: I32):   if temperature > 75:     draw(\"Great weather for a picnic!\") This function checks if the temperature is above 75 degrees. If it is, it suggests that the weather is great for a picnic. Verifying User Age Suppose you have an application that requires the user to be at least 18 years old. You can use an if statement to verify the user’s age: fn verifyAge(userAge: I32):   if userAge >= 18:     draw(\"You are eligible.\")   if userAge < 18:     draw(\"You are not eligible.\") This function displays whether the user is eligible based on their age. Using Boolean Operations with If Statements You can also use more complex conditions with Boolean operators: fn checkAccess(hasTicket: Bool, hasInvitation: Bool):   if hasTicket or hasInvitation:     draw(\"Access granted.\")   else:     draw(\"Access denied.\") This function grants access if the user has either a ticket or an invitation. Conclusion if statements are a powerful tool in Flogram that help you control the flow of your program based on conditions. By learning to use these effectively, you can make your programs smarter and more responsive to different situations. As you continue to learn Flogram, you’ll find that these conditional statements are essential in many programming tasks, reflecting Flogram’s commitment to performance and simplicity. Introduction In this lesson, we’ll explore the foreach loop in Flogram, a powerful tool for iterating over arrays and other iterable objects. The foreach loop provides a concise and readable way to process each element in a collection, making your code more expressive and efficient."
    },
    {
      "breadcrumbs": [
        "Foreach Loops"
      ],
      "href": "/tutorials/foreach_loops",
      "content": "In this lesson, we’ll explore the foreach loop in Flogram, a powerful tool for iterating over arrays and other iterable objects. The foreach loop provides a concise and readable way to process each element in a collection, making your code more expressive and efficient. Basic Syntax The basic syntax of a foreach loop in Flogram is as follows: foreach element in iterable:  # code to be executed for each element Here, element is a constant that represents the current element being processed in the loop, and iterable is the collection being iterated over, such as an array. Example: Iterating Over an Array Let’s look at a simple example of using a foreach loop to iterate over an array of numbers: fn main():    values := [10, 15, 23, 9, 60]    foreach value in values:      draw(value) In this example, the foreach loop iterates over the values array, and for each iteration, the current element is assigned to the constant value. The draw function is then called with value, which outputs each number in the array. Accessing the Index with ‘at’ Flogram’s foreach loop also allows you to access the current index of the element being processed using the optional at keyword followed by a constant name. Here’s an example: fn main():   fruits := [\"apple\", \"banana\", \"orange\"]      foreach fruit at index in fruits:     draw(\"Fruit at index {index} is {fruit}\") In this case, the foreach loop assigns the current element to the constant fruit and the current index to the constant index. The output would be: Fruit at index 0 is apple Fruit at index 1 is banana Fruit at index 2 is orange Mutating elements of the collection with ‘mut’ By default, the element constant in a foreach loop is immutable. However, Flogram allows you to mutate the element using the mut keyword. When you mutate the element, the corresponding entry in the original iterable is also mutated. This means the original collection must be mutable. Here’s an example: fn main():    mut values := [10, 15, 23, 9, 60]    foreach mut value in values:      value = value + 1      draw(values) # outputs [11, 16, 24, 10, 61] In this example, the mut keyword is used to declare value as mutable. Inside the loop, each value is incremented by 1, which modifies the original values array. 📝 Note: The index constant cannot be mutated within the loop. Best Practices When using foreach loops, consider the following best practices: Use descriptive names for the element constant to improve code readability. Avoid mutating elements unless necessary, as it can make your code harder to reason about. Conclusion The foreach loop in Flogram provides a convenient and expressive way to iterate over arrays and other iterable objects. By understanding its syntax and capabilities, such as accessing the index with at and mutating elements with mut, you can write more concise and efficient code. As you continue to learn Flogram, look for opportunities to leverage foreach loops in your own projects to simplify your code and boost your productivity."
    },
    {
      "breadcrumbs": [
        "For Loops in Flogram"
      ],
      "href": "/tutorials/for_loops",
      "content": "Introduction For loops are a fundamental control structure in programming that allow you to repeat a block of code a specified number of times. In Flogram, for loops provide a concise and flexible way to iterate over a range of values, making it easier to perform repetitive tasks and process data efficiently.\n\nBasic Syntax\nThe basic syntax of a for loop in Flogram is as follows:\n\nfor i := x up_to y by z:\n  #code to be executed for each iteration\n:= x is only required if variable is not already set\n\nHere, i is a constant that holds the current value of the loop counter, x is the initial value, up_to can be replace by almost_up_to, down_to, or almost_down_to, y is the final value, and z is the amount by which the i is incremented or decremented in each iteration. i cannot be modified within the for loop\n\nCounting Up with 'up_to' and 'almost_up_to'\nTo create a for loop that counts up, you can use either the up_to or almost_up_to keyword. The difference between the two is the condition for terminating the loop.\n\nup_to: The loop continues as long as i is less than or equal to y (i <= y).\n\nalmost_up_to: The loop continues as long as i is strictly less than end (i < y).\n\nHere’s an example that calculates the sum of numbers from 1 to 100:\n\nfn calculate_sum():\n  sum := 0\n\n  for i := 1 up_to 100 by 1:\n    sum = sum + i\n    draw(\"The sum of numbers from 1 to 100 is: {sum}\")\nCounting Down with 'down_to' and 'almost_down_to'\nSimilarly, you can create a for loop that counts down using either the down_to or almost_down_to keyword:\n\ndown_to: The loop continues as long as i is greater than or equal to y (i >= y).\n\nalmost_down_to: The loop continues as long as i is strictly greater than y (i > y).\n\nHere’s an example that prints a countdown from 10 to 1:\n\nfn countdown():\n  for i := 10 down_to 1 by 1:\n    draw(i)\n    draw(\"Liftoff!\")\nSpecifying the Step Size\nThe by clause in a for loop allows you to specify the step size, which is the amount by which the loop counter is incremented or decremented in each iteration. This is useful when you need to iterate over a range of values with a specific interval.\n\nHere’s an example that prints even numbers from 0 to 20:\n\nfn print_even_numbers():\n  for i := 0 up_to 20 by 2:\n  draw(i)\nBest Practices\nWhen using for loops in Flogram, consider the following best practices:\n\nUse foreach loops over for loops when possible. foreach loops are less likely to be buggy\n\nUse the appropriate direction keyword (up_to, almost_up_to, down_to, or almost_down_to) based on your requirements.\n\nConclusion\nFor loops in Flogram provide a powerful and flexible way to iterate over a range of values and perform repetitive tasks. By understanding the different direction keywords (up_to, almost_up_to, down_to, and almost_down_to) and the by clause for specifying the step size, you can create efficient and readable code."
    },
    {
      "breadcrumbs": [
        "While Loops in Flogram"
      ],
      "href": "/tutorials/while_loops",
      "content": "Introduction\nWhile loops are another fundamental control structure in programming that allow you to repeat a block of code as long as a specified condition is true. In Flogram, while loops provide a way to create flexible and dynamic iterations, making it easier to solve problems that require repetition based on a condition.\n\nBasic Syntax\nThe basic syntax of a while loop in Flogram is as follows:\n\nwhile condition:\n  # code to be executed while the condition is true\nHere, condition is an expression that evaluates to a Boolean value (TRUE or FALSE). The code inside the loop will continue to execute as long as the condition remains TRUE.\n\nExample: Guessing Game\nLet’s create a simple guessing game using a while loop in Flogram:\n\nfn guessing_game():\n  secret_number := 42\n  mut guess := -1\n\n  while guess != secret_number:\n  draw(\"Enter your guess:\")\n  guess := input_number()\n\n  if guess < secret_number:\n    draw(\"Too low! Try again.\")\n  if guess > secret_number:\n    draw(\"Too high! Try again.\")\n\n  draw(\"Congratulations! You guessed the secret number.\")\nIn this example, the while loop continues to prompt the user for a guess until the guess matches the secret_number. The input_number() function (assumed to be defined elsewhere) reads the user’s input as a number. The loop provides feedback to the user, indicating whether their guess is too low or too high.\n\nExample: File Processing\nAnother common use case for while loops is processing files. Here’s an example that reads lines from a file until the end of the file is reached:\n\nfn process_file(file_path: String):\nfile := open(file_path, \"r\")\nmut line := \"\"\n\nwhile (line := file.read_line()) != \"\":\n  # Process each line\n  draw(\"Processing line: {line}\")\n\nfile.close()\ndraw(\"File processing complete.\")\nIn this example, the while loop reads lines from the file using the read_line() method (assumed to be defined for the file object). The loop continues until read_line() returns an empty string, indicating the end of the file. Inside the loop, each line is processed as needed.\n\nBest Practices\nWhen using while loops in Flogram, consider the following best practices:\n\nPrefer foreach loops over for loops over while loops for performance and safety\nEnsure that the loop condition eventually becomes FALSE to avoid infinite loops.\nUse meaningful variable names for the loop condition and any variables used within the loop.\nKeep the loop body focused and concise, performing a single task or related set of tasks.\nConsider using a break statement to exit the loop early if a certain condition is met.\n\nConclusion\nWhile loops in Flogram provide a powerful way to create dynamic iterations based on a condition. By understanding the basic syntax and seeing practical examples, you can effectively use while loops to solve problems that require repetition."
    },
    {
      "breadcrumbs": [
        "Enums in Flogram"
      ],
      "href": "/tutorials/while_loops",
      "content": "Introduction\nLet’s dive deeper into enums, a powerful feature in Flogram that allows you to define a custom type with a fixed set of possible values.\n\nDefining an Enum\nTo define an enum in Flogram, use the enum keyword followed by the name of the enum, and then list the possible values the enum can take. Here’s an example:\n\nenum Weather:\n  Sunny\n  Cloudy\n  Rainy\n  Snowy\nIn this example, we’ve defined an enum called Weather. It can only have one of four possible values: Sunny, Cloudy, Rainy, or Snowy.\n\nUsing Enums\nOnce you’ve defined an enum, you can create variables of that enum type. Here’s how you might use our Weather enum:\n\nfn main():\n  todayWeather := Weather.Sunny\n  if todayWeather == Weather.Sunny:\n    draw(\"It's a sunny day!\")\n  if todayWeather == Weather.Rainy:\n    draw(\"Don't forget your umbrella!\")\nIn this code, we create a variable called todayWeather of type Weather and assign it the value Weather.Sunny. We then use if statements to check the value of todayWeather and print an appropriate message.\n\nEnums with Associated Data\nFlogram enums can also hold associated data, similar to Rust-like enums. Let’s look at an example representing different types of messages in a chat application:\n\nenum Message:\n  Text(String)\n  Image(url:String, width:I32, height:I32)\n  Video(url:String, duration:FP32)\n  File(url:String, size:I32)\nThis Message enum has four variants:\n\nText has one associated String value, representing the text content of the message.\nImage has three associated values (a String, and two I32s), which could represent the image URL, width, and height.\nVideo has two associated values (a String and an FP32), possibly representing the video URL and duration.\nFile has two associated values (a String and an I32), which could represent the file URL and file size.\nYou can create instances of these enum variants like this:\n\nfn main():\n  textMessage := Message.Text(\"Hello, how are you?\")\n  imageMessage := Message.Image(\"https://example.com/image.jpg\", 800, 600)\n  videoMessage := Message.Video(\"https://example.com/video.mp4\", 120.5)\n  fileMessage := Message.File(\"https://example.com/file.zip\", 1024)\nIn this example, the Message enum represents different types of messages in a chat application. Each variant holds data specific to that type of message. The Text variant holds the text content, the Image variant holds the URL, width, and height of the image, the Video variant holds the URL and duration of the video, and the File variant holds the URL and size of the file.\n\nIn the main function, we create instances of each type of message by calling the appropriate enum variant and providing the necessary data.\n\nThis example demonstrates how enums with associated data can be used to represent complex data structures in a clean and expressive way.\n\nEnums in Action: A Shape Calculator\nLet’s put our knowledge of enums to use by creating a simple shape calculator. We’ll define an enum called Shape with three variants: Circle (with a radius), Rectangle (with a width and height), and Triangle (with a base and height).\n\nenum Shape:\n  Circle(radius:FP32)\n  Rectangle(width:FP32, height:FP32)\n  Triangle(base:FP32, height:FP32)\n\nfn area(shape: Shape) -> FP32:\n  if shape == Shape.Circle:\n    return 3.14159 * (shape.radius * shape.radius)\n  if shape == Shape.Rectangle:\n    return (shape.width * shape.height)\n  if shape == Shape.Triangle:\n    return (shape.base * shape.height) / 2\n\nfn main():\n  circle := Shape.Circle(radius: 5)\n  rectangle := Shape.Rectangle(width:4, height:6)\n  triangle := Shape.Triangle(base:3, height:8)\n  draw(\"Area of circle: {area(circle)}\")\n  draw(\"Area of rectangle: {area(rectangle)}\")\n  draw(\"Area of triangle: {area(triangle)}\")\nIn this code, we define a function area that takes a Shape and uses if statements to check which variant of Shape it is. Based on the variant, it calculates and returns the appropriate area.\n\nIn the main function, we create instances of each shape and then print out their areas by calling the area function.\n\nConclusion\nEnums in Flogram provide a way to define custom types with a fixed set of possible values, and they can also hold associated data. They’re great for representing a set of related but distinct possibilities.\n\nIn this lesson, we saw how to define enums, create instances of enum variants, and use if statements to check which variant an enum instance is. We also saw a practical example of using enums to create a simple shape calculator."
    },
    {
      "breadcrumbs": [
        "When-Is Statements in Flogram"
      ],
      "href": "/tutorials/when_is_statements",
      "content": "Introduction\nIn this lesson, we’ll explore the when-is construct in Flogram, which provides a powerful way to match a value against specific patterns and execute code based on the matched pattern. We’ll start by using when-is to match against specific values and then discuss its usage with enums.\n\nThe When-Is Construct\nThe when-is construct in Flogram allows you to match an expression against different values and execute code based on the matched value. It provides a concise and efficient way to handle different cases based on the value of an expression.\n\nBasic Syntax\nThe basic syntax of a when-is statement is as follows:\n\nwhen expression:\n  is value1:\n    # code to execute if expression matches value1\n  is value2:\n    # code to execute if expression matches value2\n    ...\n  else:\n    # code to execute if no pattern matches\nThe expression is the value you want to match against. The is keyword is used to define each pattern, which represents a specific value or condition. The code block following each pattern is executed if the expression matches that pattern.\n\nNote that when-is cannot be used to match against variables. If statements must be used for this for now.\n\nMatching Against Specific Values\nLet’s consider an example that demonstrates using when-is to match against specific values:\n\nfn get_day_name(day_number: I32) -> String:\n  when day_number:\n    is 1:\n      return \"Monday\"\n    is 2:\n      return \"Tuesday\"\n    is 3:\n      return \"Wednesday\"\n    is 4:\n      return \"Thursday\"\n    is 5:\n      return \"Friday\"\n    is 6:\n      return \"Saturday\"\n    is 7:\n      return \"Sunday\"\n    else:\n      return \"Invalid day number\"\n  \nfn main():\n  day := 3\n  day_name := get_day_name(day)\n  draw(\"Day {day} is {day_name}\")\nIn this example, the get_day_name function uses a when-is statement to match the day_number against specific integer values representing the days of the week. Based on the matched value, it returns the corresponding day name as a string.\n\nPerformance Considerations\nWhen possible, it’s recommended to use when-is statements instead of multiple if statements for matching against specific values. The when-is construct is optimized for performance and can lead to more efficient code execution.\n\nUsing When-Is with Enums\nIn addition to matching against specific values, the when-is construct is also commonly used with enums to match against enum variants and unwrap their associated values. Here’s an example:\n\nenum Color:\n  Red\n  Green\n  Blue\n  RGB(r: U8, g: U8, b: U8)\n\nfn main():\n  color := Color.Red\n  when color:\n    is Red:\n      draw(\"It's red!\")\n    is Green:\n      draw(\"It's green!\")\n    is Blue:\n      draw(\"It's blue!\")\n    is RGB:\n      draw(\"Custom RGB color: ({color.r}, {color.g}, {color.b})\")\nIn this example, the when-is statement matches the color value against each enum variant. Since color is Color.Red, the code block following ‘is Red:’ is executed, and “It’s red!” is printed.\n\nConclusion\nThe when-is construct in Flogram provides a powerful and efficient way to match a value or expression against specific values including enums and execute code based on the matched value. When used for matching against specific values, it can lead to more performant code compared to using multiple if statements.\n\nAdditionally, when-is is often used with enums to match against enum variants and unwrap their associated values, providing a concise and expressive way to handle different cases based on the enum value.\n\nRemember to use when-is statements judiciously and consider the readability and maintainability of your code. Practice using when-is in your own projects to familiarize yourself with its syntax and behavior."
    },
    {
      "breadcrumbs": [
        "Understanding Objects in Flogram"
      ],
      "href": "/tutorials/objects",
      "content": "Introduction\nObjects are central to organizing data in many programming languages, and Flogram is no different. In this lesson, we’ll explore the concept of objects in Flogram, focusing specifically on treating them as collections of data, akin to structs in other languages.\n\nObjects as Collections of Data\nAn object in Flogram is essentially a collection of data that allows you to group other objects and primitive variables together. This makes them incredibly versatile and useful for structuring your code.\n\nDefining Objects\nYou can define an object by specifying its name and the variables it contains, along with their types. Here’s an example:\n\nobject Point:\n\n  x: FP32\n\n  y: FP32\n \n  z: FP32 = 0\nThis Point object contains three variables: x, y, and z. Note that z is given a default value of 0, so it doesn’t need to be defined when a Point object is created.\n\nCreating Instances of Objects\nTo create an instance of an object, you use the object’s name and specify the values for its variables.\n\nFor example:\n\npt := Point(x = 5, y = 2.5)\n\nptOrigin := Point(x = 0, y = 0)\nNote that most functions must start with a lowercase letter. Except for this special case, when a function is being called with an uppercase letter it is creating and returning a new object whose name matches the name of the object.\n\nObjects with mutable variables\nLike primitive variables, objects can be mutable or immutable. If you want to change the value of an object’s variable after it’s been created, you must declare it with the mut keyword:\n\nIn the following example, an object called MutablePoint is defined below as an object having an x and y coordinate that are variables and can be changed and z is a constant that cannot be changed after the object is created.\n\nobject MutablePoint:\n  mut x: FP32\n  mut y: FP32\n  z: FP32 = 0\n\nmut pt := MutablePoint(x = 3, y = 4) # Create a MutablePoint at x =3, y =4, z =0\npt.x = 10                                            # Changing the value of x\ndraw(pt.x)                                          # Outputs 10 to the screen\ndraw(pt)                                            # Outputs MutablePoint(x = 10, y =4, z =0) to the screen\ndraw(\"pt.x:{pt.x}, pt.y:{pt.y}, pt.z:{pt.z}\") # pt.x:10, pt.y:4, pt.z:0\nCopying Objects\nObjects are always copied when passed into functions or assigned to another object. This may seem inefficient, but Flogram optimizes this behavior behind the scenes to avoid unnecessary copying when possible.\n\nExample: Working with Mutable and Immutable Objects\nHere’s an example that demonstrates the use of mutable and immutable objects:\n\nobject Person:\n  mut name: String\n  age: I32\n\nfn main():\n  mut person := Person(name = \"Alice\", age = 30)\n  person.name = \"Bob\"  # Changing the name\ndraw(person.name)   # outputs Bob\ndraw(person.age)  # outputs 30\n  person.age = 35   # Error! age is not mutable\nConclusion\nObjects in Flogram act as powerful tools for grouping data, providing a way to create complex structures and organize information. Understanding how to define, create, and work with objects, both mutable and immutable, will enable you to write clean and effective code in Flogram. Experiment with objects in your own projects to see how they can help you create more organized and flexible programs.\n\nEXAMPLE CODE FOR CODE EDITOR\nobject Point2D:\n  mut x: FP32\n  mut y: FP32\n  z: FP32 = 0\n\nfn modify_point(mut p: Point2D):\n  p.x = 50\n  p.y = 60\n  \nfn main():\n  original_point := Point2D(x = 10, y = 20)\n  draw(\"Original point (before):\", original_point.x, original_point.y) # outputs Original point (before): 10 20\n\n  copied_point := original_point  # Copying the object\n  modify_point(mut copied_point)  # Modifying the copied object\n\n  draw(\"Original point (after):\", original_point.x, original_point.y) # outputs Original point (after): 10 20\n  draw(\"Copied point (after):\", copied_point.x, copied_point.y)     # outputs Copied point (after): 50 60"
    },
    {
      "breadcrumbs": [
        "Adding Functions to Objects in Flogram"
      ],
      "href": "/tutorials/object_functions",
      "content": "In Flogram, functions can be embedded within objects, allowing you to encapsulate behavior with data. This enables more organized and reusable code. Here’s how you can add functions to objects:\n\nDefining Functions Inside Objects\nFunctions within an object are defined by simply indenting the function definition under the object declaration.\n\nAccessing Object Variables with self\nThe self keyword within the function allows you to access variables belonging to the instance of the object the function is called on. An instance of an object is a specific realization of the object, containing its own set of data.\n\nHere’s an example:\n\nobject Rectangle:\n  length: FP32\n  width: FP32\n\n  fn area() -> (a: FP32):\n    return self.length * self.width\nHere’s how you can use the area function:\n\nfn main():\n  r := Rectangle(length = 5, width = 2)\n  # r.area() calls the function area on instance r of Rectangle\n  draw(r.area())  # outputs 10\nMutating Variables with Functions\nIf a function within an object mutates (changes) variables belonging to the object, the mut keyword must precede the fn keyword in the function declaration:\n\nobject Counter:\n  mut value: I32 = 0\n\n  mut fn increment() -> ():\n    self.value = +(self.value, 1)\n    return\nmut must also be used when calling a function that changes variables that belong to an object\n\nHere’s an example using the Counter object:\n\nfn main():\n  mut c := Counter()  # c.value = 0\n  mut c.increment()  # this is equivalent to c.value = c.value + 1\n  draw(c.value)  # outputs 1\nProductivity Tip!\nAvoid attaching functions to objects unless it really makes sense for the object to own that function. Using stand-alone functions that accept objects as parameters instead often leads to more maintainable code.\n\nExample for the Code Editor\nobject Point2D:\n  mut x: FP32\n  mut y: FP32\n\n  fn distanceTo(other: Point2D) -> (distance: FP32):\n    lengthX := self.x - other.x\n    lengthY := self.y - other.y\n    squareX := lengthX * lengthX\n    squareY := lengthY * lengthY\n    sum := squareX + squareY\n    distance := sqrt(sum)\n    return distance\n\n  mut fn moveBy(dx: FP32, dy: FP32):\n    self.x = self.x + dx\n    self.y = self.y + dy\n    return\n\nfn main():\n  p1 := Point2D(x = 1, y = 2)\n  p2 := Point2D(x = 4, y = 6)\n  draw(p1.distanceTo(p2)) # calculates the distance\n\n  p1.moveBy(3, 4)         # moves p1\n  draw(p1.distanceTo(p2)) # calculates the new distance"
    },
    {
      "breadcrumbs": [
        "Generics in Flogram"
      ],
      "href": "/tutorials/generics",
      "content": "Introduction\nIn this lesson, we’ll explore the concept of generics in Flogram. Generics allow you to write code that can work with different types, providing flexibility and reusability. Flogram supports generics for both functions and objects, enabling you to create more versatile and adaptable code.\n\nWhat are Generics?\nGenerics are a way to write code that can handle different types without having to specify the exact type at the time of writing. Instead, you use a placeholder type that can be substituted with a specific type when the code is used. This allows you to write functions or objects that can work with various types, reducing code duplication and increasing code reusability.\n\nGenerics in Functions\nIn Flogram, you can define generic functions using curly braces {} followed by the generic type parameter. Let’s consider an example:\n\nfn identity{T}(a: T) -> (b: T):\n    return a\n    \nfn main():\n    num := 42\n    \n    i := identity{I32}(num)\n    \n    draw(i)  # Output: 42\n    \n    name := \"Alice\"\n    \n    s := identity{String}(name)\n    \n    draw(s)  # Output: \"Alice\"\nIn this example, we define a generic function called identity that takes a parameter of type T and returns a value of the same type T. The generic type parameter T is specified within curly braces {}.\n\nWhen calling the identity function, we provide the specific type we want to use within curly braces. In the main function, we call identity{I32} to use the identity function with an integer type, and identity{String} to use it with a string type.\n\nGenerics in Objects\nFlogram also supports generics in objects, allowing you to define objects that can work with different types. Let’s consider an example of a generic Stack object:\n\nobject Stack{T}:\n    elements: [T]\n    \n    size: I32\n    \n    capacity: I32\n    \n    fn constructor(capacity: I32):\n        self.capacity = capacity\n        \n        self.elements = []\n        \n        self.size = 0\n        \n    fn push(item: T):\n        \n        if self.size == self.capacity:\n            \n            draw(\"Stack is full\")\n            \n            return\n            \n        self.elements[self.size] = item\n        \n        self.size = self.size + 1\n        \n    fn pop() -> (item: T):\n        \n        if self.isEmpty():\n            \n            draw(\"Stack is empty\")\n            \n            return\n            \n        self.size = self.size - 1\n        \n        return self.elements[self.size]\n        \n    fn isEmpty() -> (empty: Bool):\n        \n        return self.size == 0\n        \n    fn main():\n        \n        intStack := Stack{I32}(5)\n        \n        intStack.push(10)\n        \n        intStack.push(20)\n        \n        draw(intStack.pop())  # Output: 20\n        \n        stringStack := Stack{String}(3)\n        \n        stringStack.push(\"Hello\")\n        \n        stringStack.push(\"World\")\n        \n        draw(stringStack.pop())  # Output: \"World\"\nIn this example, we define a generic Stack object that can work with different types. The generic type parameter T is specified within curly braces {} after the object name.\n\nThe Stack object has an array of elements of type [T] to store the stack elements, and size and capacity variables to keep track of the stack’s size and maximum capacity.\n\nWe define methods like push, pop, and isEmpty that work with the generic type T. The push method adds an item of type T to the stack, the pop method removes and returns the top item of type T, and the isEmpty method checks if the stack is empty.\n\nIn the main function, we create instances of the Stack object with different types. We create an intStack of type Stack{I32} to store integers and a stringStack of type Stack{String} to store strings. We can push and pop elements of the respective types using the Stack object’s methods.\n\nReal-World Example: Generic Cache\n\nLet’s consider a real-world example of using generics in Flogram. Suppose you’re building a caching system that can cache different types of data, such as images, videos, or user profiles. You can use generics to create a generic Cache object that can handle various data types.\n\nobject Cache{T}:\n    data: [T]\n    \n    capacity: I32\n    \n    fn constructor(capacity: I32):\n        \n        self.capacity = capacity\n        \n        self.data = []\n        \n    fn put(item: T):\n        \n        if size(self.data) >= self.capacity:\n            \n            self.evict()\n            \n        self.data.append(item)\n        \n    fn get(index: I32) -> (item: T):\n        \n        if index >= 0 and index < size(self.data):\n            \n            return self.data[index]\n            \n        else:\n            \n            draw(\"Invalid index\")\n            \n        return\n        \n    fn evict():\n        \n        if not self.data.isEmpty():\n            \n            self.data.removeFirst()\n            \nfn main():\n    \n    imageCache := Cache{Image}(10)\n    \n    imageCache.put(Image(\"image1.jpg\"))\n    \n    imageCache.put(Image(\"image2.jpg\"))\n    \n    img := imageCache.get(0)\n    \n    draw(img)  # Output: Image(\"image1.jpg\")\n    \n    videoCache := Cache{Video}(5)\n    \n    videoCache.put(Video(\"video1.mp4\"))\n    \n    videoCache.put(Video(\"video2.mp4\"))\n    \n    vid := videoCache.get(1)\n    \n    draw(vid)  # Output: Video(\"video2.mp4\")\nIn this example, we define a generic Cache object that can store and retrieve items of different types. The generic type parameter T represents the type of data stored in the cache.\n\nThe Cache object has an array data of type [T] to store the cached items and a capacity variable to specify the maximum number of items the cache can hold.\n\nWe define methods like put to add an item to the cache, get to retrieve an item by index, and evict to remove the oldest item when the cache reaches its capacity.\n\nIn the main function, we create instances of the Cache object for different data types. We create an imageCache of type Cache{Image} to cache images and a videoCache of type Cache{Video} to cache videos. We can put and get items of the respective types using the Cache object’s methods.\n\nConclusion\nGenerics in Flogram provide a powerful way to write flexible and reusable code. By using generic type parameters, you can create functions and objects that can work with different types, reducing code duplication and increasing code adaptability.\n\nRemember to specify the generic type parameter within curly braces {} when defining generic functions or objects, and provide the specific type when using them.\n\nGenerics are particularly useful when dealing with collections, data structures, or utility functions that need to handle various types. They allow you to write more expressive and maintainable code, making your programs more robust and easier to understand.\n\nPractice using generics in your Flogram projects to familiarize yourself with their syntax and behavior. Experiment with different scenarios where generics can be applied to improve code reusability and flexibility."
    },
    {
      "breadcrumbs": [
        "Links in Flogram"
      ],
      "href": "/tutorials/links",
      "content": "Introduction In this lesson, we’ll explore the concept of links in Flogram. Links are Flogram’s version of pointers, providing a way to reference and manipulate objects stored on the heap. However, unlike traditional pointers, links in Flogram are reference-counted and safe by default, helping prevent common memory-related issues. Creating Links To create a link to an object, you can use the Link(object) syntax. Here's an example: ptLink: Link{Point} = Link(Point(x = 5, y = 5)) In this example, we create a link ptLink of type Link{Point} that points to a Point object allocated on the heap with coordinates (5, 5). Accessing Linked Data To access the data referenced by a link, you use the at(link) function. It returns the object referenced by the link. Here’s an example: fn loadTreasure(chestLink: Link{Chest}) -> (treasure: Treasure):     chest = at(chestLink)          treasure = chest.openTreasure() In this example, the loadTreasure function takes a link chestLink of type Link{Chest} and retrieves the Chest object referenced by the link using at(chestLink). It then opens the chest and retrieves the treasure inside. Passing Links Links can be passed as function parameters and returned from functions. This allows you to efficiently share and manipulate objects across different parts of your program. Here’s an example: fn shareMap(map: Map) -> (mapLink: Link{Map}):     mapLink = Link{Map}(map) In this example, the shareMap function takes a Map object and creates a link mapLink to share the map with others. Reference Counting and Safety Flogram’s links are reference-counted, meaning that the runtime keeps track of the number of references to an object. When the reference count of an object reaches zero, indicating that there are no more links pointing to it, the object is automatically deallocated, freeing up memory. Furthermore, Flogram’s compiler performs static analysis to detect potential memory-related issues, such as circular references. If a circular reference is found, the compiler will raise an error, prompting you to mark the links involved as safe using the cycle keyword. Here’s an example of marking a link as safe: object Node{T}:      value: T      cycle nextNode := Maybe{Link{Node{T}}}.None fn constructor(value: T):     self.value = value In this example, the Node object contains a link nextNode that points to another Node object, forming a potential circular reference. By adding the cycle keyword before the link declaration, you acknowledge that you have checked for cycles and deem it safe. Real-World Example: Building a Linked List Let’s consider a real-world example of using links in Flogram to build a linked list. A linked list is a data structure that consists of a sequence of nodes, where each node contains a value and a link to the next node. object LinkedList{T}:   head: Maybe{Link{Node{T}}}   fn constructor():     self.head = Maybe{Link{Node{T}}}.None   fn append(value: T):     newNode := Node{T}(value)      if self.head == Maybe{Link{Node{T}}}.None:       self.head = Link{T}(newNode)      else:       currentNode := self.head       while currentNode.nextNode != Maybe{Link{Node{T}}}.None:         currentNode = currentNode.nextNode         currentNode.nextNode = Link(newNode)   fn printValues():     currentNode := at(self.head)     while currentNode != Maybe{Link{Node{T}}}.None:       draw(“{currentNode.value}, “)        if currentNode.nextNode != Maybe{Link{Node{T}}}.None:         currentNode = currentNode.nextNode       else: 5         currentNode = Maybe{Link{Node{T}}}.None fn main():    linkedList := LinkedList{String}()    linkedList.append(\"Apple\")   linkedList.append(\"Banana\")   linkedList.append(\"Orange\")   draw(\"Linked List Values:\")   linkedList.printValues() In this example, we define a LinkedList object that represents the linked list. It has a head link that points to the first node in the list. The LinkedList object provides methods like append to add a new value to the end of the list and printValues to print all the values in the list. In the main function, we create an instance of LinkedListfunction String() { [native code] } to store strings. We append the values “Apple”, “Banana”, and “Orange” to the list using the append method. Finally, we call the printValues method to print all the values in the linked list. This example demonstrates how links in Flogram can be used to build data structures like linked lists. By using links, we can efficiently connect nodes and traverse the list without the need for manual memory management. Conclusion Links in Flogram provide a safe and efficient way to work with references to objects allocated on the heap. They are reference-counted and checked for safety at compile-time, helping prevent common memory-related issues. By using links, you can create more expressive and flexible code, allowing you to pass around and manipulate objects across different parts of your program. Flogram’s static analysis and cycle keyword help ensure the safety of your code when dealing with potential circular references. Remember to use links judiciously and consider the ownership and lifetime of the objects you are referencing. By understanding and leveraging links effectively, you can write more robust and efficient programs in Flogram. Practice using links in your Flogram projects to familiarize yourself with their syntax and behavior. Experiment with different scenarios where links can be applied to improve code organization and performance."
    }    
  ]
}